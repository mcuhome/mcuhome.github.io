<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KEIL / MDK生成BIN文件的两种方式]]></title>
    <url>%2F2019%2F08%2F03%2FKEIL-MDK%E7%94%9F%E6%88%90BIN%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[KEIL / MDK生成BIN文件的两种方式1 KEIL工程配置入口点击“魔术棒”图标（Option for Target） 在After Build/Rebuild选项卡中，勾选 “Run # 1”,在后面输入框写入bin文件生成方式，见2.1、2.2 2 输出Bin文件配置​ KEIL生成bin文件，根据输入命令的相对\绝对路径来分，有两种方式，都是通过自带的fromelf.exe来生成 2.1 绝对路径方式绝对路径方式，如果更换电脑等，需要手动修改MDK工具链(formelf.exe)所在路径与项目文件名(例如test_app) 1&quot;D:\Program Files\MDK516\ARM\ARMCC\bin\fromelf.exe&quot; --bin -o ./obj/test_app.bin ./obj/test_app.axf&quot; 2.2 相对路径方式使用相对路径生成，则不需要任何修改 1$K\ARM\ARMCC\bin\fromelf.exe --bin --output=@L.bin !L 编译后，Build Out框可以看到：After Build - User command #1: D:\Program Files\MDK516\ARM\ARMCC\bin\fromelf.exe –bin –output=test1.bin .\obj\test1.axf 上述操作后，在xxx.uvprojx当前目录下，可看到一个test1.bin 如果希望生成.bin文件输出在当前工程下的指定目录，比如Bin文件夹，可如下操作： 1$K\ARM\ARMCC\bin\fromelf.exe --bin --output=Bin\@L.bin !L 编译后，Build Out框可以看到：After Build - User command #1: D:\Program Files\MDK516\ARM\ARMCC\bin\fromelf.exe –bin –output=Bin\test1.bin .\obj\test1.axf 上述操作后，在xxx.uvprojx当前目录下，可看到一个新生成的Bin文件夹，里面是test1.bin ​ 符号代号（Key Code） $ 扩展为 指定文件的路径名 @ 表示 Output -&gt; Name of Exectable:定义的工程名,比如工程后，最终生成的bin文件名称将是test1.bin ! 当前目录下的扩展路径 !L编译(Build)后，就是 .\obj\xx.axf文件 文件代号（File Code） K keil develop chaintool 工具链（fromelf.exe） L Linker output fileL.bin 编译后，生成的就是最终的xx.bin文件 ​ 3 参考资料1.原文链接(Keil官方)：Key Sequence for Tool Parametershttp://www.keil.com/support/man/docs/uv4/uv4_ut_keysequence.htm 2.https://blog.csdn.net/veabol/article/details/52318694 3.https://blog.csdn.net/nich2009/article/details/81124691]]></content>
  </entry>
  <entry>
    <title><![CDATA[电子烟控制板功能说明]]></title>
    <url>%2F2019%2F07%2F26%2FEGO%E7%94%B5%E5%AD%90%E7%83%9F%E6%8E%A7%E5%88%B6%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[※ 组件结构尺寸 EGO电子烟控制板由主控板组件和红黑蓝三条/四条导线组成，主控板尺寸为9.8mm*11mm，板厚0.8mm±0.1，按键高度2.5mm 导线规格可按客户要求定制。 ​ ※ 电气参数（实际应用差异影响以下参数） 表2 参数表 参数项 典型值 单位 工作范围电压 1.6~5.0 V 工作额定电压 3.2~4.2 V 雾化器电阻值 1.0～3.5 Ohm 待机模式电流 ≤1.0 uA LED灯电流 （LED灯电压可以支持到3V） 10 mA 雾化器输出是PWM方式 3.7 V 充电输入电压范围 4.2V~5.5V V 恒流充电电流（Icc） 400/600 mA 终止充电电流（Iterm） 0.1*Icc mA 工作温度 -20~80 ℃ ※ 使用功能说明 3.1 上电IC自检，LED连闪2次（200ms ON，200ms OFF）进入待机模式。 3.2 待机模式下，在2秒内连续接按键5次后，锁机；锁机时，2秒内连续按按键5次后，回到待机模式；而且在充电中可支持吸烟的场景中，依然支持此锁机和解锁模式。 3.3 输出电压方式是PWM，当电池电压＞4.1V时PWM占空比90%（空载），当电池电压3.9V~4.1V时PWM占空比93%（空载），当电池电压3.7V~3.9V时PWM占空比97%（空载），当电池电压3.3V~3.7V时PWM占空比100%（空载）。 3.4 在待机模式下，用户按键， LED灯亮；电池电压低于3.2V后，LED灯连闪15次（200ms ON，200ms OFF），继续待机。 3.5 在待机模式下，吸烟时需按住按键开关，启动雾化器， 开始吸烟；停止吸烟时，需把按键放开，关闭雾化器。 按键按住超过10秒，LED闪3次（200ms ON，200ms OFF），雾化器停止工作。 3.6 雾化器短路后，用户按键，LED闪3次（200ms ON，200ms OFF），处于短路保护状态。吸烟时雾化器短路LED闪3次（200ms ON，200ms OFF），处于大电流保护状态。 ※ 充电说明 4.1 烟杆接上充电，LED闪烁5次（200ms ON，200ms OFF）后LED常亮，处于充电状态。在电池电压低于2.8V时，为涓流充电，电流40mA；大于2.8V时，开始以恒流充电；电压充到4.2V（±0.05V），且充电电流下降到充电电流的1/10后，LED灯灭，充电截止；拔出充电器LED闪2次。如果在未充满电的情况下，而此时电池电压已经达到或超过4.1V（±0.07V），再充电时LED闪烁5次后LED灯灭，充电截止。 4.2 充电输入电压范围 充电输入电压4.2V~5.5V。 ※**产品外观** CT811QM4是一款可充电电子烟专用咪头，产品主体直径6mm，高度2.7mm，外接四条导线，LED灯色和线材规格可按客户要求定制。 黑线 GND 连接电池负极 注：LED灯色和线材长度根据客户要求定制 红线 VDD 连接电池正极 蓝线 OUT 连接输出正极 黄线 CHG 连接充电正极 ※**电气参数（外围线路影响以下参数）** 参数项 最小值 典型值 最大值 单位 工作范围电压 1.7 5 V 工作额定电压 3.2 4.2 V 雾化器电阻值 1.35 Ω 吸烟开关功率MOS Rds-on 100 mΩ 待机电流 5 uA 吸烟启动时间 30 100 mS LED电流 5 mA LED闪灯周期 0.4 S 吸烟中LED灯渐亮时间 0.5 S 吸烟中LED灯渐灭时间 1 S 雾化器输出电压PWM方式 3.7 V 稳压电源充电电压 4.2 5.5 V 恒流充电电流(Icc) 200 mA 终止充电电流(Iterm) 20 mA 电容检测变化开关阀值 1.6 % 工作温度 -20 80 ℃ ※ 主要功能 No. 功能 说明 1 电池电压 3.2V~4.2V(标配电池：3.7V锂电池 )。 2 省电电流 睡眠模式下小于5uA。 3 吸烟超时 一次吸烟超过10秒关闭输出同时LED灯闪3次，然后进入待机状态 4 上电提示 芯片上电IC自检，LED连闪2次后进入待机模式。 5 开机/解锁 在1.5秒内连续吸烟3次为开锁机切换，LED灯闪2次提示。 如在锁机状态下充电，可解除锁定即回到开机状态。 6 吸烟提示 芯片在吸烟过程中，LED有渐亮、渐灭功能。渐亮时间为0.5s，渐灭时间为1s；当LED灯亮时雾化器发热并有烟雾产生，当LED灯灭时，雾化器不发热，无烟雾产生。 7 输出电压 输出恒压3.7V 误差±0.05V 8 大电流保护 雾化器电流在3A或以上，LED闪3次，处于大电流保护状态 9 短路保护 发热丝低于1.35欧单片机判定为短路，吸烟时按键灯和电量灯闪3次提示。 10 低压提示 BAT＜3.20±0.1V(空载)，吸烟时按键灯闪10次提示，无电压输出。 11 充电 1.烟杆接上充电，LED常亮，处于充电状态。在电池电压低于2.8V时，为涓流充电，电流20mA；大于2.8V时，开始以恒流200mA充电；电压充到4.2V（±0.05V），且充电电流下降到20mA后，LED灯灭，充电截止；拔出充电器LED闪2次。如果在未充满电的情况下，而此时电池电压已经达到或超过4.1V（±0.07V），再充电时LED灯灭，充电截止。 2.充电输入电压范围 充电输入电压为4.3V~5.5V。 ※**产品外观** CT811QM是一款可充电电子烟专用咪头，产品主体直径6mm，高度2.7mm，外接三条导线，LED灯色和线材规格可按客户要求定制。 引线功能 黑线 GND 电源负极 注：灯色和线材长度根据客户要求定制 红线 VDD 电源正极 蓝线 OUT 输出正极 ※**电气参数（外围线路影响以下参数）** 参数项 最小值 典型值 最大值 单位 工作范围电压 1.7 5 V 工作额定电压 3.2 4.2 V 雾化器电阻值 1.35 Ω 吸烟开关功率MOS Rds-on 100 mΩ 待机电流 5 uA 吸烟启动时间 30 100 mS LED电流 5 mA LED闪灯周期 0.4 S 吸烟中LED灯渐亮时间 0.5 S 吸烟中LED灯渐灭时间 1 S 雾化器输出电压PWM方式 3.7 V 稳压电源充电电压 4.2 5.5 V 恒流充电电流(Icc) 200 mA 终止充电电流(Iterm) 20 mA 电容检测变化开关阀值 1.6 % 工作温度 -20 80 ℃ ※ 主要功能 No. 功能 说明 1 电池电压 3.2V~4.2V(标配电池：3.7V锂电池 )。 2 省电电流 睡眠模式下小于5uA。 3 吸烟超时 一次吸烟超过10秒关闭输出同时LED灯闪3次，然后进入待机状态 4 上电提示 芯片上电IC自检，LED连闪2次后进入待机模式。 5 开机/解锁 在1.5秒内连续吸烟3次为开锁机切换，LED灯闪2次提示。 如在锁机状态下充电，可解除锁定即回到开机状态。 6 吸烟提示 芯片在吸烟过程中，LED有渐亮、渐灭功能。渐亮时间为0.5s，渐灭时间为1s；当LED灯亮时雾化器发热并有烟雾产生，当LED灯灭时，雾化器不发热，无烟雾产生。 7 输出电压 输出恒压3.7V 误差±0.05V 8 大电流保护 雾化器电流在3A或以上，LED闪3次，处于大电流保护状态 9 短路保护 发热丝低于1.35欧单片机判定为短路，吸烟时按键灯和电量灯闪3次提示。 10 低压提示 BAT＜3.20±0.1V(空载)，吸烟时按键灯闪10次提示，无电压输出。 11 充电 1.烟杆接上充电，LED常亮，处于充电状态。在电池电压低于2.8V时，为涓流充电，电流20mA；大于2.8V时，开始以恒流200mA充电；电压充到4.2V（±0.05V），且充电电流下降到20mA后，LED灯灭，充电截止；拔出充电器LED闪2次。如果在未充满电的情况下，而此时电池电压已经达到或超过4.1V（±0.07V），再充电时LED灯灭，充电截止。 2.充电输入电压范围 充电输入电压为4.3V~5.5V。 ※**产品外观** CT815是一款可充电电子烟专用咪头，产品主体直径6mm，高度2.7mm，外接五条导线，LED灯色和线材规格可按客户要求定制。 黑线① GND 连接电池负极&amp;输出负极 注：LED灯色和线材长度根据客户要求定制 红线 VDD 连接电池正极 蓝线 OUT 连接输出正极 黄线 CHG 连接充电正极 黑线② GND 连接充电负极 ※**电气参数（外围线路影响以下参数）** 参数项 最小值 典型值 最大值 单位 工作范围电压 1.7 5 V 工作额定电压 3.2 4.2 V 雾化器电阻值 1.35 Ω 吸烟开关功率MOS Rds-on 100 mΩ 待机电流 5 uA 吸烟启动时间 30 100 mS LED电流 5 mA LED闪灯周期 0.4 S 吸烟中LED灯渐亮时间 0.5 S 吸烟中LED灯渐灭时间 1 S 雾化器输出电压PWM方式 3.7 V 稳压电源充电电压 4.2 5.5 V 恒流充电电流(Icc) 200 230 mA 终止充电电流(Iterm) 20 mA 电容检测变化开关阀值 1.6 % 工作温度 -20 80 ℃ ※ 主要功能 No. 功能 说明 1 电池电压 3.2V~4.2V(标配电池：3.7V锂电池 )。 2 省电电流 睡眠模式下小于5uA。 3 吸烟超时 一次吸烟超过10秒关闭输出同时LED灯闪3次，然后进入待机状态 4 上电提示 芯片上电IC自检，LED连闪2次后进入待机模式。 5 吸烟提示 芯片在吸烟过程中，LED有渐亮、渐灭功能。渐亮时间为0.5s，渐灭时间为1s；当LED灯亮时雾化器发热并有烟雾产生，当LED灯灭时，雾化器不发热，无烟雾产生。 6 输出电压 输出恒压3.7V 误差±0.05V 7 大电流保护 雾化器电流在3A或以上，LED闪3次，处于大电流保护状态 8 短路保护 发热丝低于1.35欧单片机判定为短路，吸烟时按键灯和电量灯闪3次提示。 9 低压提示 BAT＜3.20±0.1V(空载)，吸烟时按键灯闪10次提示，无电压输出。 10 充电 1.可连接单独的充电口，LED常亮，处于充电状态。在电池电压低于2.8V时，为涓流充电，电流20mA；大于2.8V时，开始以恒流200～230mA充电；电压充到4.2V（±0.05V），且充电电流下降到20mA后，LED灯灭，充电截止；拔出充电器LED闪2次。如果在未充满电的情况下，而此时电池电压已经达到或超过4.1V（±0.07V），再充电时LED灯灭，充电截止。 2.充电输入电压范围 充电输入电压为4.3V~5.5V。 ※**产品规格** 1.咪头主体尺寸规格 尺寸规格 直径 高度 LED 灵敏度 咪头主体 6.0mm±0.1 2.7mm±0.1 客户指定 -400Pa以内 ​ 咪头外接三条导线，导线规格可根据客户要求定制。 ※ 主要功能 1.1输出电流在2.5A(±0.5A)或以上，LED闪1次，处于大电流保护状态。 1.2吸烟一口时长超过12秒(误差±30%)LED灭，输出自动截止。 1.3吸烟过程中，LED灯有渐亮、渐灭效果。 ※ 电气参数（外围线路影响以下参数） 参数项 典型值 单位 工作范围电压 1.8~5.5 V 工作额定电压 1.8~4.2 V 待机电流 ＜5.0 μA 雾化器输出电压 同电池电压 V 工作温度 -20~85 ℃ ※ 使用功能说明 3.1芯片上电IC自检，LED闪1次再进入待机模式。5 3.2当加上雾化器做吸烟动作时，IC输出导通来启动雾化器工作。 3.3吸烟工作过程中，LED渐亮、渐灭，同时在LED灯亮时雾化器发热并有烟雾产生，即LED灯灭时，雾化器不发热，无烟雾产生。 3.4吸烟过程中，吸烟一口时长超过12秒(误差±30%)，LED灯灭，同时雾化器不发热，烟雾自动停止。 3.5当电池电压低于1.8V时，芯片不工作。 ※ 原理图]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何使用虚拟机(vmware workstation)安装Ubuntu系统]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA-vmware-workstation-%E5%AE%89%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[本文只使用最简单的方式去安装虚拟机（vmware workstation）和ubuntu。 1.下载360安全卫士，在360软件管家搜索“虚拟机”，如下图 2.找到“vmware workstation”，随后点击下载安装。 如需注册码请到官方网站购买或者在下方评论中找 3.安装完成之后到Ubuntu官方下载Ubuntu系统. 我用的是ubuntu-16.04.5-desktop-amd64版本，目前最低版本是18.04，直接点击download，如下图 4.下载完成后，打开Vmware workstation软件，打开“文件-&gt;新建虚拟机” 5.然后使用典型安装， 6.找到下载好的光盘镜像文件 7.输入名字和密码，密码一定要记住，后面开机和编程时获取权限用的到； 8.填入虚拟机名字，设置安装ubuntu的位置，这个光盘最好有20G以上空间。 9.为Ubuntu分配空间，一般20G就够用了。 10.点击完成就等待Ubuntu安装了，看机子的配置，一般20多分钟就可以搞定。 11.看，正在安装！ 输入密码，大功告成了！ 下一步，配置ESP32编译环境！]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建基于Ubuntu的 ESP32 开发环境]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EUbuntu%E7%9A%84-ESP32-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[本人使用ubuntu系统来开发ESP32也有一年多了，为给后人提供经验，故写下自己的经验，让后人少走弯路。 Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu 是基于DebianGNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的。 使用linux编译的好处是相比于windows系统，Linux更快，更方便。 1.如何使用虚拟机安装Ubuntu系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030的模拟I2C与博世BMI160六轴传感器通信]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%9F%BA%E4%BA%8Estm32f030%E7%9A%84%E6%A8%A1%E6%8B%9FI2C%E4%B8%8E%E5%8D%9A%E4%B8%96BMI160%E5%85%AD%E8%BD%B4%E4%BC%A0%E6%84%9F%E5%99%A8%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[博世BMI160简介 ​ Bosch Sensortec公司推出的最新BMI160惯性测量单元将最顶尖的16位3轴重力加速度计和超低功耗3轴陀螺仪集成于单一封装。采用14管脚LGA封装，尺寸为2.5×3.0×0.8mm3。当加速度计和陀螺仪在全速模式下运行时，耗电典型值低至950µA，仅为市场上同类产品耗电量的50%或者更低。 BMI160是一款高度集成的低功耗惯性测量单元（IMU），可提供精确的加速度和角速率（陀螺 仪）测量。 主要特点 高性能加速度计和陀螺仪（硬件同步） 功耗极低：典型值。 920μA（全功能加速度计和陀螺仪） 符合Android Kitkat：重要的运动和步进检测器/步进计数器（每个5μA） 占地面积2.5 x 3.0 mm2，高度0.83 mm 内置电源管理单元（PMU），用于高级电源管理 具有快速启动陀螺仪模式的省电功能 宽电源范围：1.71V …… 3.6V 可分配的1024字节FIFO缓冲区（能够处理外部传感器数据） 硬件传感器时间戳，用于精确的传感器数据融合 集成中断，用于增强自主运动检测 灵活的数字主接口，通过I2C或SPI连接主机 扩展I2C模式，时钟频率高达1 MHz 用于OIS应用的附加二级高速接口 能够处理外部传感器数据 (例如Bosch Sensortec的地磁或气压传感器) 下载地址BMI160的中文Datasheet的下载连接如下： [点击此处进入下载网页] 官方英文Datasheet下载地址 官方参考驱动代码下载地址 主接口I2C / SPI协议选择 ​ 从上面的框图中，我们可以看到，BMI160与外部进行双向数据传输的方式有两种：SPI和I2C。下面，我们来看下通过I2C与外部进行通信的方式。当BMI160通过I2C与外部进行通信的时候，BMI160将作为I2C从设备挂到主控芯片（主设备）的I2C总线上，所以，主控芯片在配置其对应的I2C驱动时就需要知道BMI160的从设备地址。 ​ 上电后，根据芯片选择CSB引脚行为自动选择协议。复位/上电时，BMI160处于I2C模式。 如果CSB在上电期间连接到VDDIO且未更改，则传感器接口 在I2C模式下工作。 对于使用I2C，建议将CSB线硬连线到VDDIO。 由于上电复位仅在VDD和 VDDIO都建立时执行，因此不存在由于上电顺序而导致协议检测错误的风险。 ​ 如果CSB在上电后看到上升沿，则BMI160接口切换到SPI直到复位或下一次上电。 因此，在启 动SPI之前需要CSB上升沿通讯。 ​ 因此，建议在实际通信之前对ADDRESS 0x7F执行SPI单读访问，以便使用SPI接口。 如果没有数据，则无法切换CSB位通信时，寄存器（0x70）NV_CONF中还有spi_en位，可用于将 主接口永久设置为SPI，而无需在每次上电或复位时切换CSB引脚。 本文采用的是I2C接口 I2C接口如果SDO引脚被拉至’GND‘，器件的I²C地址为0b1101000（0x68）。 如果SDO引脚被拉至VDDIO‘，器件的I²C地址为0b1101001（0x69）。 I2C时序图下图给出的I²C时序的定义 I²C协议的工作原理如下： START： 总线上的数据传输从SDA线上的高电平到低电平转换开始，而SCL保持高电平（I²C总 线主机指示的启动条件（S））。 一旦主机传输START信号，总线就会被认为是忙碌的。 STOP: 每个数据传输应由主机产生的停止信号（P）终止。 STOP条件是SDA线上的低电平到高 电平转换，而SCL保持高电平。 ACKS: 必须确认传输的每个数据字节。 它由接收器发送的确认位指示。 发送器必须在应答脉冲 期间释放SDA线（无下拉），而接收器必须将SDA线拉低，以便在应答时钟周期的高电平期间保 持稳定的低电平。 I²C写数据I²C写访问可用于在一个序列中写入数据字节。 该序列以主机产生的启动条件开始，后跟7位从机地址和写入位（RW = 0）。 从器件发送一个应 答位（ACKS = 0）并释放总线。 然后主机发送一个字节的寄存器地址。 从机再次确认传输并等 待8位数据，这些数据应写入指定的寄存器地址。 从机确认数据字节后，主机产生停止信号并终 止写入协议。I²C写访问的示例： I²C读数据I²C读访问也可用于在一个序列中读取一个或多个数据字节。I²C读访问也可用于在一个序列中读取一个或多个数据字节。读序列由一个字节的I²C写阶段和I C读阶段组成。变速器的两个部分必须通过重复启动条件（S）分开。 I²C写入阶段寻址从器件并发送要读取的寄存器地址。从机确认发送后，主机再次产生一个起始条件，并将从机地址与读取位（RW = 1）一起发送。然后主机释放总线并等待从从机读出数据字节。在每个数据字节之后，主机必须生成应答位（ACKS = 0）以启用进一步的数据传输。来自主设备的NACKM（ACKS = 1）停止从从设备传输的数据。从器件释放总线，以便主器件可以生成STOP条件并终止传输。寄存器地址自动递增，因此可以顺序读出多个字节。一旦新的数据读取传输开始，起始地址将被设置为自最新的I²C写入命令以来指定的寄存器地址。默认情况下，起始地址设置为0x00。以这种方式，可以从相同的起始地址重复多字节读取。 I²C读访问示例（读取陀螺仪数据）： I²C读写初始化程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/**************************实现函数*********************************************函数原型: void IIC_Start(void)*功 能: 产生IIC起始信号*******************************************************************************/void IIC_Start(void)&#123; SDA_OUT(); //sda线输出 IIC_SDA_1; IIC_SCL_1; delay_us(5); IIC_SDA_0;//START:when CLK is high,DATA change form high to low delay_us(5); IIC_SCL_0;//钳住I2C总线，准备发送或接收数据 &#125;/**************************实现函数*********************************************函数原型: void IIC_Stop(void)*功 能: //产生IIC停止信号*******************************************************************************/ void IIC_Stop(void)&#123; SDA_OUT();//sda线输出 IIC_SCL_0; IIC_SDA_0;//STOP:when CLK is high DATA change form low to high delay_us(5); IIC_SCL_1; IIC_SDA_1;//发送I2C总线结束信号 delay_us(5); &#125;/**************************实现函数*********************************************函数原型: u8 IIC_Wait_Ack(void)*功 能: 等待应答信号到来 //返回值：1，接收应答失败// 0，接收应答成功*******************************************************************************/u8 IIC_Wait_Ack(void)&#123; u8 ucErrTime=0; SDA_IN(); //SDA设置为输入 IIC_SDA_1; delay_us(5); while(READ_SDA) &#123; ucErrTime++; if(ucErrTime&gt;50) &#123; IIC_Stop(); return 1; &#125; delay_us(5); &#125; IIC_SCL_1; delay_us(5); IIC_SCL_0;//时钟输出0 return 0; &#125; /**************************实现函数*********************************************函数原型: void IIC_Ack(void)*功 能: 产生ACK应答*******************************************************************************/void IIC_Ack(void)&#123; IIC_SCL_0; SDA_OUT(); IIC_SDA_0; delay_us(5); IIC_SCL_1; delay_us(5); IIC_SCL_0;&#125; /**************************实现函数*********************************************函数原型: void IIC_NAck(void)*功 能: 产生NACK应答*******************************************************************************/ void IIC_NAck(void)&#123; IIC_SCL_0; SDA_OUT(); IIC_SDA_1; delay_us(5); IIC_SCL_1; delay_us(5); IIC_SCL_0;&#125; /**************************实现函数*********************************************函数原型: void IIC_Send_Byte(u8 txd)*功 能: IIC发送一个字节*******************************************************************************/ void IIC_Send_Byte(u8 txd)&#123; u8 t; SDA_OUT(); IIC_SCL_0;//拉低时钟开始数据传输 for(t=0;t&lt;8;t++) &#123; if(txd&amp;0x80) IIC_SDA_1; //IIC_SDA=1; else IIC_SDA_0; //IIC_SDA=0; txd&lt;&lt;=1; delay_us(2); IIC_SCL_1; delay_us(5); IIC_SCL_0; delay_us(3); &#125; &#125; /**************************实现函数*********************************************函数原型: u8 IIC_Read_Byte(unsigned char ack)*功 能: //读1个字节，ack=1时，发送ACK，ack=0，发送nACK *******************************************************************************/ u8 IIC_Read_Byte(unsigned char ack)&#123; unsigned char i,receive=0; SDA_IN();//SDA设置为输入 for(i=0;i&lt;8;i++ ) &#123; IIC_SCL_0; delay_us(5); IIC_SCL_1; receive&lt;&lt;=1; if(READ_SDA)receive++; delay_us(5); &#125; if (ack) IIC_Ack(); //发送ACK else IIC_NAck();//发送nACK return receive;&#125;/**************************实现函数*********************************************功 能: 读取指定设备 指定寄存器的 length个值输入 dev 目标设备地址 reg 寄存器地址 length 要读的字节数 *data 读出的数据将要存放的指针返回 读出来的字节数量*******************************************************************************/ u8 IICreadBytes(u8 dev, u8 reg, u8 *data , uint16_t length)&#123; u8 count = 0; IIC_Start(); IIC_Send_Byte(dev&lt;&lt;1); //发送写命令 IIC_Wait_Ack(); IIC_Send_Byte(reg); //发送地址 IIC_Wait_Ack(); IIC_Start(); IIC_Send_Byte((dev&lt;&lt;1)+1); //进入接收模式 IIC_Wait_Ack(); for(count=0;count&lt;length;count++)&#123; if(count!=length-1)data[count]=IIC_Read_Byte(1); //带ACK的读数据 else data[count]=IIC_Read_Byte(0); //最后一个字节NACK &#125; IIC_Stop();//产生一个停止条件 return 0;&#125;/**************************实现函数*********************************************功 能: 将多个字节写入指定设备 指定寄存器输入 dev 目标设备地址 reg 寄存器地址 length 要写的字节数 *data 将要写的数据的首地址返回 返回是否成功*******************************************************************************/ u8 IICwriteBytes(u8 dev, u8 reg, u8 *data , uint16_t length)&#123; u8 count = 0; IIC_Start(); IIC_Send_Byte(dev&lt;&lt;1); //发送写命令 IIC_Wait_Ack(); IIC_Send_Byte(reg); //发送地址 IIC_Wait_Ack(); for(count=0;count&lt;length;count++)&#123; IIC_Send_Byte(data[count]); IIC_Wait_Ack(); &#125; IIC_Stop();//产生一个停止条件 return 0; //status == 0; &#125; 初始化完成之后，就可以结合官方库区读取数据了。 首先对BMI160初始化 123456789101112131415161718192021222324252627282930313233343536struct bmi160_dev bmi160sensor ;void mybmi160_init(void)//BMI160初始化&#123;// struct bmi160_dev bmi160sensor; int8_t rslt = BMI160_OK; bmi160sensor.id = BMI160_I2C_ADDR; bmi160sensor.interface = BMI160_I2C_INTF; bmi160sensor.read = IICreadBytes; bmi160sensor.write = IICwriteBytes; bmi160sensor.delay_ms = delay_ms; bmi160sensor.chip_id=0; IICreadBytes(BMI160_I2C_ADDR,BMI160_CHIP_ID_ADDR, &amp;bmi160sensor.chip_id, 1); printf(&quot;bmi_id=%d\n&quot;,bmi160sensor.chip_id);// bmi160_get_regs2(BMI160_CHIP_ID_ADDR, &amp;bmi160sensor.chip_id, 1, dev); rslt = bmi160_init(&amp;bmi160sensor); /* Select the Output data rate, range of accelerometer bmi160sensor */ bmi160sensor.accel_cfg.odr = BMI160_ACCEL_ODR_800HZ; bmi160sensor.accel_cfg.range = BMI160_ACCEL_RANGE_4G; bmi160sensor.accel_cfg.bw = BMI160_ACCEL_BW_NORMAL_AVG4; /* Select the power mode of accelerometer bmi160sensor */ bmi160sensor.accel_cfg.power = BMI160_ACCEL_NORMAL_MODE; /* Select the Output data rate, range of Gyroscope bmi160sensor */ bmi160sensor.gyro_cfg.odr = BMI160_GYRO_ODR_800HZ; bmi160sensor.gyro_cfg.range = BMI160_GYRO_RANGE_2000_DPS; bmi160sensor.gyro_cfg.bw = BMI160_GYRO_BW_NORMAL_MODE; /* Select the power mode of Gyroscope bmi160sensor */ bmi160sensor.gyro_cfg.power = BMI160_GYRO_NORMAL_MODE; /* Set the bmi160sensor configuration */ rslt = bmi160_set_sens_conf(&amp;bmi160sensor); /* After the above function call, accel and gyro parameters in the device structure are set with default values, found in the datasheet of the bmi160sensor */&#125; 获取陀螺仪和加速度数据 12345678910111213141516171819202122232425262728293031323334353637383940414243//获取数据void get_accel_gyro_data2(void)&#123; uint8_t data_array[15] = &#123;0&#125;; uint8_t lsb; uint8_t msb; int16_t msblsb; int16_t gx,gy,gz,ax,ay,az; IICreadBytes(BMI160_I2C_ADDR,BMI160_GYRO_DATA_ADDR,data_array,15);//获取陀螺仪的数据 lsb = data_array[0]; msb = data_array[1]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); gx = msblsb; /* gyro X axis data */ lsb = data_array[2]; msb = data_array[3]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); gy = msblsb; /* gyro Y axis data */ lsb = data_array[4]; msb = data_array[5]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); gz = msblsb; /* gyro Z axis data */ /* Accel Data */ lsb = data_array[6]; msb = data_array[7]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); ax = (int16_t)msblsb; /* accel X axis data */ lsb = data_array[8]; msb = data_array[9]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); ay = (int16_t)msblsb; /* accel Y axis data */ lsb = data_array[10]; msb = data_array[11]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); az = (int16_t)msblsb; /* accel Z axis data */ printf(&quot;gyro-&gt;x=%d,y=%d,z=%d,accel-&gt;x=%d,y=%d,z=%d \n&quot;,gx,gy,gz,ax,ay,az);&#125; 设置为任意方向中断，这样可以通过示波器查看，当摇晃BMI160时，观察中断通道1是否有高电平产生了。 123456789101112131415161718192021222324252627void bmi160_Interrupt(void)//设置任意方向中断&#123; struct bmi160_int_settg int_config; int8_t rslt = BMI160_OK; /* Select the Interrupt channel/pin */ int_config.int_channel = BMI160_INT_CHANNEL_1;// Interrupt channel/pin 1 /* Select the Interrupt type */ int_config.int_type = BMI160_ACC_ANY_MOTION_INT;// Choosing Any motion interrupt /* Select the interrupt channel/pin settings */ int_config.int_pin_settg.output_en = BMI160_ENABLE;// Enabling interrupt pins to act as output pin int_config.int_pin_settg.output_mode = BMI160_DISABLE;// Choosing push-pull mode for interrupt pin int_config.int_pin_settg.output_type = BMI160_ENABLE;// Choosing active low output int_config.int_pin_settg.edge_ctrl = BMI160_ENABLE;// Choosing edge triggered output int_config.int_pin_settg.input_en = BMI160_DISABLE;// Disabling interrupt pin to act as input int_config.int_pin_settg.latch_dur = BMI160_LATCH_DUR_40_MILLI_SEC;// non-latched output /* Select the Any-motion interrupt parameters */ int_config.int_type_cfg.acc_any_motion_int.anymotion_en = BMI160_ENABLE;// 1- Enable the any-motion, 0- disable any-motion int_config.int_type_cfg.acc_any_motion_int.anymotion_x = BMI160_ENABLE;// Enabling x-axis for any motion interrupt int_config.int_type_cfg.acc_any_motion_int.anymotion_y = BMI160_ENABLE;// Enabling y-axis for any motion interrupt int_config.int_type_cfg.acc_any_motion_int.anymotion_z = BMI160_ENABLE;// Enabling z-axis for any motion interrupt int_config.int_type_cfg.acc_any_motion_int.anymotion_dur = 0;// any-motion duration int_config.int_type_cfg.acc_any_motion_int.anymotion_thr = 100; /* Set the Any-motion interrupt */ rslt=bmi160_set_int_config(&amp;int_config, &amp;bmi160sensor); /* bmi160sensor is an instance of the structure bmi160_dev */&#125; 更多其他详细程序请到我的公众号或者github查找。]]></content>
  </entry>
  <entry>
    <title><![CDATA[美信DS28E05单总线EEPROM通信方式详解（以STM32F030为例）]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%BE%8E%E4%BF%A1DS28E05%E5%8D%95%E6%80%BB%E7%BA%BFEEPROM%E4%B8%8ESTM32F030%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述​ DS28E05是一款112字节用户可编程EEPROM芯片，分为7页，每页16字节。存储器页通过保护字节可单独设置为写保护或者EPROM仿真模式。每个器件都带有唯一的64位ROM注册码(ROM ID)，由工厂刻入器件。DS28E05通过Maxim Integrated单触点1-Wire®接口高速通信，在多点1-Wire网络中，ROM ID作为节点地址。 关键特性单触点1-Wire接口 112字节用户EEPROM，具有1K次写循环 用户存储器可编程为写保护以及OTP EPROM仿真模式 唯一、工厂编程的64位ROM ID 与主机通信速率高达76.9kbps (仅高速模式) 工作范围：3.3V ±10%, -40°C至+85°C IO引脚具有±8kV HBM ESD保护(典型值) 3引脚SOT23和6引脚TSOC封装 应用配件/PCB识别 消费品的售后管理 模拟感应器校准 医用传感器校准数据存储 通信方式与程序​ DS28E05是通过单总线协议连接的，根据文档显示，标准的单总线协议是不行的，只能使用快速的单总线协议（Overdrive Speed）才行。 如图为读写周期的时间，最短的读写周期仅有2个微秒，注意读的时候不要超过2个微秒，否则就读不出数据了。 复位时序图 12345678910111213141516171819202122/******************************************1-Wire器件复位, 并检查应答;有应答返回0, 无应答返回1*******************************************/ unsigned char Reset( void )&#123; unsigned char testCount = 50; GPIO_DS28E05_Out_Mode(); DS28E05_Write_1(); DS28E05_Write_0(); delay_us(60); //复位60us低脉冲保持 DS28E05_Write_1(); //释放总线后9us读应答 GPIO_DS28E05_Input_Mode(); while(testCount--) &#123; if( 0 == DS28E05_ReadBit() ) &#123; delay_us(2); return 0; &#125; &#125; return 1;&#125; 写数据时序图 写数据程序1234567891011121314151617181920212223/****************************************** 写数据位1*******************************************/void WriteBit_1( void )&#123; DS28E05_Write_1(); DS28E05_Write_0(); //拉低总线保持1us delay_us(1); DS28E05_Write_1(); //释放总线延时大于12us delay_us(20);//20us&#125;/****************************************** 写数据位0*******************************************/void WriteBit_0( void )&#123; DS28E05_Write_1(); DS28E05_Write_0(); //拉低总线保持8-16us delay_us(12); //9-10us DS28E05_Write_1(); //释放总线延时6us delay_us(9);&#125; 读数据程序 12345678910111213141516/****************************************** 读数据位*******************************************/unsigned char value1;static unsigned char Read_Bit( void )&#123; GPIO_DS28E05_Out_Mode(); DS28E05_Write_1(); DS28E05_Write_0(); //拉低总线保持1us delay_us(1); DS28E05_Write_1(); DS28e05_IO_IN();//最重要的一步，一定要用寄存器操作，否则会错过读取的时间，经检测，整个读取周期为2-3微妙 value1 = DS28E05_ReadBit(); delay_us(2); return value1; &#125; 写一个字节1234567891011121314151617181920/****************************************** 写字节*******************************************/static void Write_Byte( unsigned char value )&#123; unsigned char i; GPIO_DS28E05_Out_Mode(); for( i = 0; i &lt; 8; i++ ) &#123; if( value &amp; 0x01 ) &#123; WriteBit_1(); &#125; else &#123; WriteBit_0(); &#125; value = value &gt;&gt; 1; &#125;&#125; 读一个字节123456789101112131415/****************************************** 读字节*******************************************/static unsigned char Read_Byte( void )&#123; int i, value; value = 0; for( i = 0; i &lt; 8; i++ ) &#123; value &gt;&gt;= 1; if( Read_Bit() ) value |= 0x80; &#125; return value;&#125; 读写ROM和flash123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/******************************************功能：读8位家族码;48位序列号;8位CRC码;读取成功返回0参数：*id--读取的数据存放地址返回：0--操作成功；1--总线不可用;*******************************************/unsigned char DS28E05_ReadRom( unsigned char *id )&#123; unsigned char i,j; while(Reset()); Write_Byte( Rom_Read_Cmd ); //写命令 for( i = 0; i &lt; 8; i++ ) &#123; j= Read_Byte(); *id++ = j; &#125; return ( 0 ); &#125;/******************************************功能： 读EPROM参数： tgaddr--目标地址; len--要读取的字节数; *buffer--存放地址返回：0--操作成功；1--总线不可用;*******************************************/unsigned char DS28E05_ReadMemory( unsigned char tgaddr, unsigned char len, unsigned char * buffer )&#123; unsigned char i; if( Reset() != 0 ) return ( 1 ); Write_Byte( Rom_Skip_Cmd ); //写命令 Write_Byte( Memory_Read_Cmd ); //写命令 Write_Byte( tgaddr ); //写地址低字节 Write_Byte( 0 ); //写地址高字节 for( i = 0; i &lt; len; i++ ) &#123; buffer[ i ] = Read_Byte(); &#125; Reset(); return ( 0 ); &#125;//写eepromint ds28e05WriteMemory(uint8_t address, char *buffer, int length)&#123; uint8_t a,b; uint8_t sf,ef; uint8_t sb[2]=&#123;0&#125;; uint8_t eb[2]=&#123;0&#125;; uint8_t spage, epage, npage, wpage; uint8_t nseg, wseg=0; uint8_t wBytes=0, rBytes=0, wAddr = 0; // Calculate pages spage = ((address &amp; PAGE_MASK) &gt;&gt; 4); epage = (((address + length) &amp; PAGE_MASK) &gt;&gt; 4); if (epage == NUM_PAGES) epage = NUM_PAGES - 1; npage = epage - spage; printf(&quot;spage=%d,epage=%d\n&quot;,spage,epage); printf(&quot;npage=%d,length=%d\n&quot;,npage,length); //This memory must be written respecting 16bits boundaries sf = (address&amp;0x01) != 0; ef = ((address+length)&amp;0x01) != 0; printf(&quot;sf=%d,ef=%d\n&quot;,sf,ef); if (ef) &#123; DS28E05_ReadMemory( address+length,1, &amp;eb[1]); eb[0] = buffer[length-1]; length++; &#125; if (sf) &#123; DS28E05_ReadMemory(address-1,1, &amp;sb[0]); sb[1] = buffer[0]; length++; address--; &#125; // Write pages for (wpage = 0; wpage &lt;= npage; wpage++) &#123; wAddr = address + wBytes; // Calculate segments to write if ((length - wBytes) &gt; (BYTES_PER_PAGE)) // Will we pass a page boudary if (wAddr % (SEG_SIZE * BYTES_PER_SEG) == 0) nseg = SEG_SIZE; else nseg = (BYTES_PER_PAGE - (wAddr % (BYTES_PER_PAGE))) &gt;&gt; 1; else nseg = ((length - wBytes) &amp; SEG_MASK) &gt;&gt; 1; printf(&quot;nseg=%d\n&quot;,nseg); if( Reset() != 0 ) return ( 1 ); Write_Byte( Rom_Skip_Cmd ); Write_Byte(DS28E05_WRITE_MEMORY); Write_Byte(wAddr); Write_Byte(0xff); // Write segments within page for (wseg = 0; wseg &lt; nseg; wseg++) &#123; if (sf) &#123; Write_Byte(sb[0]); Write_Byte(sb[1]); wBytes += 2; rBytes++; sf = 0; &#125; else if (ef &amp;&amp; (length - wBytes) &lt;= 2) &#123; Write_Byte(eb[0]); Write_Byte(eb[1]); wBytes += 2; rBytes++; ef = 0; &#125; else &#123; Write_Byte(buffer[rBytes]); Write_Byte(buffer[rBytes+1]); wBytes += 2; rBytes += 2; &#125; a = Read_Byte(); b = Read_Byte(); printf(&quot;Readback: %02x %02x (%c%c)\n&quot;, a, b, a, b); Write_Byte(0xff); delay_ms(16); a = Read_Byte(); printf(&quot;Verification byte: %02x\n&quot;, a); if(a !=0xAA) goto error; &#125; Reset();; &#125; return 1;error: Reset(); return 0;&#125; 详细的程序，请到我的github仓库查找或者关注我的公众号索取。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深圳的同学注意了，你也可以免费下载知网论文]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%B7%B1%E5%9C%B3%E7%9A%84%E5%90%8C%E5%AD%A6%E6%B3%A8%E6%84%8F%E4%BA%86%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E7%9F%A5%E7%BD%91%E8%AE%BA%E6%96%87%2F</url>
    <content type="text"><![CDATA[​ 受知乎回答启发，深圳的同学也能享受到免费下载知网的文章的便利，条件便是要拥有深圳图书馆的借书证。 以下是操作步骤： ​ 1.先用借书证，登录深圳图书馆[https://www.szlib.org.cn/ ],如图找到数字资源-，然后点击馆外访问， ，然后就可以用知网下载了。 怎么样，是不是很方便呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[这是一个新的博客]]></title>
    <url>%2F2019%2F05%2F12%2F%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是一个博客，如有问题请加QQ咨询916100357.]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo博客建立方法]]></title>
    <url>%2F2018%2F07%2F24%2Fhexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。 而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。 那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 教程分三个部分， 第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。第二部分：hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流第三部分：hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。第一部分hexo的初级搭建还有部署到github page上，以及个人域名的绑定。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 Hexo搭建步骤安装Git安装Node.js安装HexoGitHub创建个人仓库生成SSH添加到GitHub将hexo部署到GitHub设置个人域名发布文章 1.安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 sudo apt-get install git 安装好后，用git –version 来查看一下版本 2.安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： sudo apt-get install nodejssudo apt-get install npm安装完后，打开命令行 node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3.安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo hexo init myblog 这个myblog可以自己取什么名字都行，然后 cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题 _config.yml: 博客的配置文件hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 大概长这样： 使用ctrl+c可以把服务关掉。 4.GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 点击create repository。 5.生成SSH添加到GitHub回到你的git bash中， git config –global user.name “yourname”git config –global user.email “youremail” 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 git config user.namegit config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C “youremail”这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 在gitbash中，查看是否成功 ssh -T git@github.com 6.将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git –save 然后 hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 7.设置个人域名现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 注册一个阿里云账户,在阿里云上买一个域名，我买的是 fangzh.top，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。 你需要先去进行实名认证,然后在域名控制台中，看到你购买的域名。 点解析进去，添加解析。 其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。注意，解析线路选择默认，不要像我一样选境外。这个境外是后面来做国内外分流用的,在后面的博客中会讲到。记得现在选择默认！！ 登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名fangzh.top 然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名。 最后，在gitbash中，输入 hexo cleanhexo ghexo d 过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！ 接下来你就可以正式开始写文章了。 hexo new newpapername 然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再 hexo cleanhexo ghexo d 就可以看到更新了。 第二部分hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。 1.hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 网站参数 描述title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址参数 描述url 网址root 网站根目录permalink 文章的 永久链接 格式permalink_defaults 永久链接中各部分的默认值在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。 参数 结果:year/:month/:day/:title/ 2013/07/14/hello-world:year-:month-:day-:title.html 2013-07-14-hello-world.html:category/:title foo/bar/hello-world再往下翻，中间这些都默认就好了。 theme: landscape Deployment Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: branch: [branch] theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。 接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： title: Hello World date: 2013/7/13 20:46:25 下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述layout 布局title 标题date 建立日期updated 更新日期comments 开启文章的评论功能tags 标签（不适用于分页）categories 分类（不适用于分页）permalink 覆盖文章网址其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 categories: Diarytags: PS3 Games layout（布局）当你每一次使用代码 hexo new paper它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。 Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径post source/_postspage sourcedraft source/_drafts而new这个命令其实是： hexo new [layout] 只不过这个layout默认是post罢了。 page如果你想另起一页，那么可以使用 hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是http://xxx.xxx/board draftdraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 hexo new draft newpage 这样会在source/_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 hexo server –draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， hexo publish draft newpage 就会自动把newpage.md发送到post中。 2.更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里 这里有200多个主题可以选。不过最受欢迎的就是那么几个，比如NexT主题，非常的简洁好看，大多数人都选择这个，关于这个的教程也比较多。不过我选择的是hueman这个主题，好像是从WordPress移植过来的，展示效果如下： 不管怎么样，至少是符合我个人的审美。 直接在github链接上下载下来，然后放到theme文件夹下就行了，然后再在刚才说的配置文件中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。 而后进入hueman这个文件夹，可以看到里面也有一个配置文件_config.xml，貌似它默认是_config.xml.example，把它复制一份，重命名为_config.xml就可以了。这个配置文件是修改你整个主题的配置文件。 menu（菜单栏）也就是上面菜单栏上的这些东西。 其中，About这个你是找不到网页的，因为你的文章中没有about这个东西。如果你想要的话，可以执行命令 hexo new page about 它就会在根目录下source文件夹中新建了一个about文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。 如果你想要自己再自定义一个菜单栏的选项，那么就 hexo new page yourdiy 然后在主题配置文件的menu菜单栏添加一个 Yourdiy : /yourdiy，注意冒号后面要有空格，以及前面的空格要和menu中默认的保持整齐。然后在languages文件夹中，找到zh-CN.yml，在index中添加yourdiy: ‘中文意思’就可以显示中文了。 customize(定制)在这里可以修改你的个人logo，默认是那个hueman，在source/css/images文件夹中放入自己要的logo，再改一下url的链接名字就可以了。 favicon是网站中出现的那个小图标的icon，找一张你喜欢的logo，然后转换成ico格式，放在images文件夹下，配置一下路径就行。 social_links ，可以显示你的社交链接，而且是有logo的。 tips: 在这里可以添加一个rss功能，也就是那个符号像wifi一样的东西。 添加RSS 1.什么是RSS？RSS也就是订阅功能，你可以理解为类似与订阅公众号的功能，来订阅各种博客，杂志等等。 2.为什么要用RSS？就如同订阅公众号一样，你对某个公众号感兴趣，你总不可能一直时不时搜索这个公众号来看它的文章吧。博客也是一样，如果你喜欢某个博主，或者某个平台的内容，你可以通过RSS订阅它们，然后在RSS阅读器上可以实时推送这些消息。现在网上的垃圾消息太多了，如果你每一天都在看这些消息中度过，漫无目的的浏览，只会让你的时间一点一点的流逝，太不值得了。如果你关注的博主每次都发的消息都是精华，而且不是每一天十几条几十条的轰炸你，那么这个博主就值得你的关注，你就可以通过RSS订阅他。 在我的理解中，如果你不想每天都被那些没有质量的消息轰炸，只想安安静静的关注几个博主，每天看一些有质量的内容也不用太多，那么RSS订阅值得你的拥有。 3.添加RSS功能先安装RSS插件 npm i hexo-generator-feed 而后在你整个项目的_config.yml中找到Extensions，添加： Extensions Plugins: https://hexo.io/plugins/ RSS订阅 plugin: hexo-generator-feedFeed Atom feed: type: atom path: atom.xml limit: 20 这个时候你的RSS链接就是 域名/atom.xml了。 所以，在主题配置文件中的这个social links，开启RSS的页面功能，这样你网站上就有那个像wifi一样符号的RSS logo了，注意空格。 rss: /atom.xml 4.如何关注RSS？首先，你需要一个RSS阅读器，在这里我推荐inoreader，宇宙第一RSS阅读器，而且中文支持的挺好。不过它没有PC端的程序，只有网页版，chrome上有插件。在官网上用google账号或者自己注册账号登录，就可以开始你的关注之旅了。 每次需要关注某个博主时，就点开他的RSS链接，把链接复制到inoreader上，就能关注了，当然，如果是比较大众化的很厉害的博主，你直接搜名字也可以的，比如每个人都非常佩服的阮一峰大师，直接在阅读器上搜索阮一峰，应该就能出来了。 我关注的比如，阮一峰的网络日志，月光博客，知乎精选等，都很不错。当然，还有我！！赶快关注我吧！你值得拥有：http://fangzh.top/atom.xml 在安卓端，inoreader也有下载，不过因为国内google是登录不了的，你需要在inoreader官网上把你的密码修改了，然后就可以用账户名和密码登录了。 在IOS端，没用过，好像是reader 3可以支持inoreader账户，还有个readon也不错，可以去试试。 widgets(侧边栏)侧边栏的小标签，如果你想自己增加一个，比如我增加了一个联系方式，那么我把communication写在上面，在zh-CN.yml中的sidebar，添加communication: ‘中文’。 然后在hueman/layout/widget中添加一个communicaiton.ejs，填入模板： &lt;% if (site.posts.length) { %&gt; &lt;%= __(‘sidebar.communiation’) %&gt; &lt;% } %&gt; search(搜索框)默认搜索框是不能够用的， you need to install hexo-generator-json-content before using Insight Search 它已经告诉你了，如果想要使用，就安装这个插件。 comment(评论系统)这里的多数都是国外的，基本用不了。这个valine好像不错，还能统计文章阅读量，可以自己试一试，链接。 miscellaneous(其他)这里我就改了一个links，可以添加友链。注意空格要对！不然会报错！ 总结：整个主题看起来好像很复杂的样子，但是仔细捋一捋其实也比较流畅， languages: 顾名思义layout：布局文件，其实后期想要修改自定义网站上的东西，添加各种各样的信息，主要是在这里修改，其中comment是评论系统，common是常规的布局，最常修改的在这里面，比如修改页面head和footer的内容。scripts：js脚本，暂时没什么用source：里面放了一些css的样式，以及图片 3.git分支进行多终端工作问题来了，如果你现在在自己的笔记本上写的博客，部署在了网站上，那么你在家里用台式机，或者实验室的台式机，发现你电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？ 在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 机制机制是这样的，由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。 也就是上传的是在本地目录里自动生成的.deploy_git里面。 其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github 所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。 上传分支首先，先在github上新建一个hexo分支，如图： 然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。 然后在本地的任意目录下，打开git bash， git clone git@github.com:ZJUFangzh/ZJUFangzh.github.io.git 将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。 接下来在克隆到本地的ZJUFangzh.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： .DS_StoreThumbs.dbdb.json.lognode_modules/public/.deploy/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。 而后 git add .git commit –m “add branch”git push 这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。 这样就上传完了。 更换电脑操作一样的，跟之前的环境搭建一样， 安装gitsudo apt-get install git 设置git全局邮箱和用户名git config –global user.name “yourgithubname”git config –global user.email “yourgithubemail” 设置ssh keyssh-keygen -t rsa -C “youremail” 生成后填到github和coding上（有coding平台的话） 验证是否成功 ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话) 安装nodejssudo apt-get install nodejssudo apt-get install npm 安装hexosudo npm install hexo-cli -g 但是已经不需要初始化了， 直接在任意文件夹下， git clone git@……………… 然后进入克隆到的文件夹： cd xxx.github.ionpm installnpm install hexo-deployer-git –save 生成，部署： hexo ghexo d 然后就可以开始写你的新博客了 hexo new newpage Tips: 不要忘了，每次写完最好都把源文件上传一下git add .git commit –m “xxxx”git push 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了git pull 4.coding page上部署实现国内外分流之前我们已经把hexo托管在github了，但是github是国外的，而且百度的爬虫是不能够爬取github的，所以如果你希望你做的博客能够在百度引擎上被收录，而且想要更快的访问，那么可以在国内的coding page做一个托管，这样在国内访问就是coding page，国外就走github page。 申请coding账户，新建项目 先申请一个账户，然后创建新的项目，这一步项目名称应该是随意的。 添加ssh key 这一步跟github一样。 添加后，检查一下是不是添加成功 ssh -T git@git.coding.net 修改_config.yml hexo官方文档是这样的： deploy: type: git message: [message] repo: github: ,[branch] coding: ,[branch] 那么，我们只需要： deploy: type: git repo: coding: git@git.coding.net:ZJUFangzh/ZJUFangzh.git,master github: git@github.com:ZJUFangzh/ZJUFangzh.github.io.git,master 部署 保存一下，直接 hexo ghexo d 这样就可以在coding的项目上看到你部署的文件了。 5.开启coding pages服务，绑定域名如图： 6.阿里云添加解析这个时候就可以把之前github的解析改成境外，把coding的解析设为默认了。 7.去除coding page的跳转广告coding page的一个比较恶心人的地方就是，你只是银牌会员的话，访问会先跳转到一个广告，再到你自己的域名。那么它也给出了消除的办法。右上角切换到coding的旧版界面，默认新版是不行的。然后再来到pages服务这里。 这里： 只要你在页面上添加一行文字，写Hosted by Coding Pages，然后点下面的小勾勾，两个工作日内它就会审核通过了。 Hosted by Coding Pages 我的选择是把这一行代码放在主题文件夹/layout/common/footer.ejs里面，也就是本来在页面中看到的页脚部分。 当然，为了统一，我又在后面加上了and Github哈哈，可以不加。 Hosted by Coding Pages and Github 这是最终加上去的代码。 第三部分hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。 本文参考了: visugar.com这里面说的很详细了。 1.SEO优化推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。 SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 百度seo刚建站的时候是没有搜索引擎收录我们的网站的。可以在搜索引擎中输入site:&lt;域名&gt; 来查看一下。 登录百度站长平台添加网站 登录百度站长平台，在站点管理中添加你自己的网站。 验证网站有三种方式：文件验证、HTML标签验证、CNAME验证。 第三种方式最简单，只要将它提供给你的那个xxxxx使用CNAME解析到xxx.baidu.com就可以了。也就是登录你的阿里云，把这个解析填进去就OK了。 提交链接 我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎 npm install hexo-generator-sitemap –savenpm install hexo-generator-baidu-sitemap –save 这时候你需要在你的根目录下_config.xml中看看url有没有改成你自己的： 重新部署后，就可以在public文件夹下看到生成的sitemap.xml和baidusitemap.xml了。 然后就可以向百度提交你的站点地图了。 这里建议使用自动提交。 自动提交又分为三种：主动推送、自动推送、sitemap。 可以三个一起提交不要紧，我选择的是后两种。 自动推送：把百度生成的自动推送代码，放在主题文件/layout/common/head.ejs的适当位置，然后验证一下就可以了。sitemap：把两个sitemap地址，提交上去，看到状态正常就OK了。 ps: 百度收录比较慢，慢慢等个十天半个月再去site:&lt;域名&gt;看看有没有被收录。 google的SEO流程一样，google更简单，而且收录更快，进入google站点地图，提交网站和sitemap.xml，就可以了。 如果你这个域名在google这里出了问题，那你就提交 yourname.github.io，这个链接，效果是一样的。 不出意外的话一天内google就能收录你的网站了。 其他的搜索，如搜狗搜索，360搜索，流程是一样的，这里就不再赘述。 2.评论系统评论系统有很多，但是很多都是墙外的用不了，之前说过这个valine好像集成在hueman和next主题里面了，但是我还没有研究过，我看的是visugar这个博主用的来比力评论系统，感觉也还不错。 来比力官网，注册好后，点击管理页面，在代码管理中找到安装代码： 获取安装代码后，在主题的comment下新建一个文件放入刚刚那段代码，再找到article文件，找到如下代码，若没有则直接在footer后面添加即可。livebe即为刚刚所创文件名称。 &lt;%- partial(‘comment/livebe’) %&gt; 然后可以自己设置一些东西： 还可以设置评论提醒，这样别人评论你的时候就可以及时知道了。 3.添加百度统计百度统计可以在后台上看到你网站的访问数，浏览量，浏览链接分布等很重要的信息。所以添加百度统计能更有效的让你掌握你的网站情况。 百度统计，注册一下，这里的账号好像和百度账号不是一起的。 照样把代码复制到head.ejs文件中，然后再进行一下安装检查，半小时左右就可以在百度统计里面看到自己的网站信息了。 4.文章阅读量统计leanCloudleanCloud，进去后注册一下，进入后创建一个应用： 在存储中创建Class，命名为Counter, 然后在设置页面看到你的应用Key，在主题的配置文件中： leancloud_visitors: enable: true app_id: 你的id app_key: 你的key在article.ejs中适当的位置添加如下，这要看你让文章的阅读量统计显示在哪个地方了， 阅读数量:次 然后在footer.ejs的最后，添加： var APP_ID = '你的app id'; var APP_KEY = '你的app key'; AV.init({ appId: APP_ID, appKey: APP_KEY }); // 显示次数 function showTime(Counter) { var query = new AV.Query("Counter"); if($(".leancloud_visitors").length > 0){ var url = $(".leancloud_visitors").attr('id').trim(); // where field query.equalTo("words", url); // count query.count().then(function (number) { // There are number instances of MyClass where words equals url. $(document.getElementById(url)).text(number? number : '--'); }, function (error) { // error is an instance of AVError. }); } } // 追加pv function addCount(Counter) { var url = $(".leancloud_visitors").length > 0 ? $(".leancloud_visitors").attr('id').trim() : 'icafebolger.com'; var Counter = AV.Object.extend("Counter"); var query = new Counter; query.save({ words: url }).then(function (object) { }) } $(function () { var Counter = AV.Object.extend("Counter"); addCount(Counter); showTime(Counter); }); 重新部署后就可以了。 5.引入不蒜子访问量和访问人次统计不蒜子的添加非常非常方便，不蒜子 在footer.ejs中的合适位置，看你要显示在哪个地方，添加： 本站总访问量次 &nbsp; 访客数人次 就可以了。 总结到这里就基本做完了。其实都是参考别的博主的设置的，不一定仅限于hueman主题，其他主题的设置也是大体相同的，所以如果你希望设置别的主题，那么仔细看一下这个主题的代码结构，也能够把上边的功能添加进去。 多看看别的博主的那些功能，如果有你能找到自己喜欢的功能，那么好好发动搜索技能，很快就能找到怎么做了。加油吧！]]></content>
  </entry>
</search>
