<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于stm32f030的模拟I2C与博世BMI160六轴传感器通信]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%9F%BA%E4%BA%8Estm32f030%E7%9A%84%E6%A8%A1%E6%8B%9FI2C%E4%B8%8E%E5%8D%9A%E4%B8%96BMI160%E5%85%AD%E8%BD%B4%E4%BC%A0%E6%84%9F%E5%99%A8%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[博世BMI160简介 ​ Bosch Sensortec公司推出的最新BMI160惯性测量单元将最顶尖的16位3轴重力加速度计和超低功耗3轴陀螺仪集成于单一封装。采用14管脚LGA封装，尺寸为2.5×3.0×0.8mm3。当加速度计和陀螺仪在全速模式下运行时，耗电典型值低至950µA，仅为市场上同类产品耗电量的50%或者更低。 BMI160是一款高度集成的低功耗惯性测量单元（IMU），可提供精确的加速度和角速率（陀螺 仪）测量。 主要特点 高性能加速度计和陀螺仪（硬件同步） 功耗极低：典型值。 920μA（全功能加速度计和陀螺仪） 符合Android Kitkat：重要的运动和步进检测器/步进计数器（每个5μA） 占地面积2.5 x 3.0 mm2，高度0.83 mm 内置电源管理单元（PMU），用于高级电源管理 具有快速启动陀螺仪模式的省电功能 宽电源范围：1.71V …… 3.6V 可分配的1024字节FIFO缓冲区（能够处理外部传感器数据） 硬件传感器时间戳，用于精确的传感器数据融合 集成中断，用于增强自主运动检测 灵活的数字主接口，通过I2C或SPI连接主机 扩展I2C模式，时钟频率高达1 MHz 用于OIS应用的附加二级高速接口 能够处理外部传感器数据 (例如Bosch Sensortec的地磁或气压传感器) 下载地址BMI160的中文Datasheet的下载连接如下： [点击此处进入下载网页] 官方英文Datasheet下载地址 官方参考驱动代码下载地址 主接口I2C / SPI协议选择 ​ 从上面的框图中，我们可以看到，BMI160与外部进行双向数据传输的方式有两种：SPI和I2C。下面，我们来看下通过I2C与外部进行通信的方式。当BMI160通过I2C与外部进行通信的时候，BMI160将作为I2C从设备挂到主控芯片（主设备）的I2C总线上，所以，主控芯片在配置其对应的I2C驱动时就需要知道BMI160的从设备地址。 ​ 上电后，根据芯片选择CSB引脚行为自动选择协议。复位/上电时，BMI160处于I2C模式。 如果CSB在上电期间连接到VDDIO且未更改，则传感器接口 在I2C模式下工作。 对于使用I2C，建议将CSB线硬连线到VDDIO。 由于上电复位仅在VDD和 VDDIO都建立时执行，因此不存在由于上电顺序而导致协议检测错误的风险。 ​ 如果CSB在上电后看到上升沿，则BMI160接口切换到SPI直到复位或下一次上电。 因此，在启 动SPI之前需要CSB上升沿通讯。 ​ 因此，建议在实际通信之前对ADDRESS 0x7F执行SPI单读访问，以便使用SPI接口。 如果没有数据，则无法切换CSB位通信时，寄存器（0x70）NV_CONF中还有spi_en位，可用于将 主接口永久设置为SPI，而无需在每次上电或复位时切换CSB引脚。 本文采用的是I2C接口 I2C接口如果SDO引脚被拉 至’GND’，器件的I²C地址为0b1101000（0x68）。 通过将SDO引脚拉至’VDDIO’来选择备用地址0b1101001（0x69）。 I2C时序图下图给出的I²C时序的定义 I²C协议的工作原理如下： START： 总线上的数据传输从SDA线上的高电平到低电平转换开始，而SCL保持高电平（I²C总 线主机指示的启动条件（S））。 一旦主机传输START信号，总线就会被认为是忙碌的。 STOP: 每个数据传输应由主机产生的停止信号（P）终止。 STOP条件是SDA线上的低电平到高 电平转换，而SCL保持高电平。 ACKS: 必须确认传输的每个数据字节。 它由接收器发送的确认位指示。 发送器必须在应答脉冲 期间释放SDA线（无下拉），而接收器必须将SDA线拉低，以便在应答时钟周期的高电平期间保 持稳定的低电平。 I²C写数据I²C写访问可用于在一个序列中写入数据字节。 该序列以主机产生的启动条件开始，后跟7位从机地址和写入位（RW = 0）。 从器件发送一个应 答位（ACKS = 0）并释放总线。 然后主机发送一个字节的寄存器地址。 从机再次确认传输并等 待8位数据，这些数据应写入指定的寄存器地址。 从机确认数据字节后，主机产生停止信号并终 止写入协议。I²C写访问的示例： I²C读数据I²C读访问也可用于在一个序列中读取一个或多个数据字节。I²C读访问也可用于在一个序列中读取一个或多个数据字节。读序列由一个字节的I²C写阶段和I C读阶段组成。变速器的两个部分必须通过重复启动条件（S）分开。 I²C写入阶段寻址从器件并发送要读取的寄存器地址。从机确认发送后，主机再次产生一个起始条件，并将从机地址与读取位（RW = 1）一起发送。然后主机释放总线并等待从从机读出数据字节。在每个数据字节之后，主机必须生成应答位（ACKS = 0）以启用进一步的数据传输。来自主设备的NACKM（ACKS = 1）停止从从设备传输的数据。从器件释放总线，以便主器件可以生成STOP条件并终止传输。寄存器地址自动递增，因此可以顺序读出多个字节。一旦新的数据读取传输开始，起始地址将被设置为自最新的I²C写入命令以来指定的寄存器地址。默认情况下，起始地址设置为0x00。以这种方式，可以从相同的起始地址重复多字节读取。 I²C读访问示例（读取陀螺仪数据）： I²C读写初始化程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/**************************实现函数*********************************************函数原型: void IIC_Start(void)*功 能: 产生IIC起始信号*******************************************************************************/void IIC_Start(void)&#123; SDA_OUT(); //sda线输出 IIC_SDA_1; IIC_SCL_1; delay_us(5); IIC_SDA_0;//START:when CLK is high,DATA change form high to low delay_us(5); IIC_SCL_0;//钳住I2C总线，准备发送或接收数据 &#125;/**************************实现函数*********************************************函数原型: void IIC_Stop(void)*功 能: //产生IIC停止信号*******************************************************************************/ void IIC_Stop(void)&#123; SDA_OUT();//sda线输出 IIC_SCL_0; IIC_SDA_0;//STOP:when CLK is high DATA change form low to high delay_us(5); IIC_SCL_1; IIC_SDA_1;//发送I2C总线结束信号 delay_us(5); &#125;/**************************实现函数*********************************************函数原型: u8 IIC_Wait_Ack(void)*功 能: 等待应答信号到来 //返回值：1，接收应答失败// 0，接收应答成功*******************************************************************************/u8 IIC_Wait_Ack(void)&#123; u8 ucErrTime=0; SDA_IN(); //SDA设置为输入 IIC_SDA_1; delay_us(5); while(READ_SDA) &#123; ucErrTime++; if(ucErrTime&gt;50) &#123; IIC_Stop(); return 1; &#125; delay_us(5); &#125; IIC_SCL_1; delay_us(5); IIC_SCL_0;//时钟输出0 return 0; &#125; /**************************实现函数*********************************************函数原型: void IIC_Ack(void)*功 能: 产生ACK应答*******************************************************************************/void IIC_Ack(void)&#123; IIC_SCL_0; SDA_OUT(); IIC_SDA_0; delay_us(5); IIC_SCL_1; delay_us(5); IIC_SCL_0;&#125; /**************************实现函数*********************************************函数原型: void IIC_NAck(void)*功 能: 产生NACK应答*******************************************************************************/ void IIC_NAck(void)&#123; IIC_SCL_0; SDA_OUT(); IIC_SDA_1; delay_us(5); IIC_SCL_1; delay_us(5); IIC_SCL_0;&#125; /**************************实现函数*********************************************函数原型: void IIC_Send_Byte(u8 txd)*功 能: IIC发送一个字节*******************************************************************************/ void IIC_Send_Byte(u8 txd)&#123; u8 t; SDA_OUT(); IIC_SCL_0;//拉低时钟开始数据传输 for(t=0;t&lt;8;t++) &#123; if(txd&amp;0x80) IIC_SDA_1; //IIC_SDA=1; else IIC_SDA_0; //IIC_SDA=0; txd&lt;&lt;=1; delay_us(2); IIC_SCL_1; delay_us(5); IIC_SCL_0; delay_us(3); &#125; &#125; /**************************实现函数*********************************************函数原型: u8 IIC_Read_Byte(unsigned char ack)*功 能: //读1个字节，ack=1时，发送ACK，ack=0，发送nACK *******************************************************************************/ u8 IIC_Read_Byte(unsigned char ack)&#123; unsigned char i,receive=0; SDA_IN();//SDA设置为输入 for(i=0;i&lt;8;i++ ) &#123; IIC_SCL_0; delay_us(5); IIC_SCL_1; receive&lt;&lt;=1; if(READ_SDA)receive++; delay_us(5); &#125; if (ack) IIC_Ack(); //发送ACK else IIC_NAck();//发送nACK return receive;&#125;/**************************实现函数*********************************************功 能: 读取指定设备 指定寄存器的 length个值输入 dev 目标设备地址 reg 寄存器地址 length 要读的字节数 *data 读出的数据将要存放的指针返回 读出来的字节数量*******************************************************************************/ u8 IICreadBytes(u8 dev, u8 reg, u8 *data , uint16_t length)&#123; u8 count = 0; IIC_Start(); IIC_Send_Byte(dev&lt;&lt;1); //发送写命令 IIC_Wait_Ack(); IIC_Send_Byte(reg); //发送地址 IIC_Wait_Ack(); IIC_Start(); IIC_Send_Byte((dev&lt;&lt;1)+1); //进入接收模式 IIC_Wait_Ack(); for(count=0;count&lt;length;count++)&#123; if(count!=length-1)data[count]=IIC_Read_Byte(1); //带ACK的读数据 else data[count]=IIC_Read_Byte(0); //最后一个字节NACK &#125; IIC_Stop();//产生一个停止条件 return 0;&#125;/**************************实现函数*********************************************功 能: 将多个字节写入指定设备 指定寄存器输入 dev 目标设备地址 reg 寄存器地址 length 要写的字节数 *data 将要写的数据的首地址返回 返回是否成功*******************************************************************************/ u8 IICwriteBytes(u8 dev, u8 reg, u8 *data , uint16_t length)&#123; u8 count = 0; IIC_Start(); IIC_Send_Byte(dev&lt;&lt;1); //发送写命令 IIC_Wait_Ack(); IIC_Send_Byte(reg); //发送地址 IIC_Wait_Ack(); for(count=0;count&lt;length;count++)&#123; IIC_Send_Byte(data[count]); IIC_Wait_Ack(); &#125; IIC_Stop();//产生一个停止条件 return 0; //status == 0; &#125; 初始化完成之后，就可以结合官方库区读取数据了。 首先对BMI160初始化 123456789101112131415161718192021222324252627282930313233343536struct bmi160_dev bmi160sensor ;void mybmi160_init(void)//BMI160初始化&#123;// struct bmi160_dev bmi160sensor; int8_t rslt = BMI160_OK; bmi160sensor.id = BMI160_I2C_ADDR; bmi160sensor.interface = BMI160_I2C_INTF; bmi160sensor.read = IICreadBytes; bmi160sensor.write = IICwriteBytes; bmi160sensor.delay_ms = delay_ms; bmi160sensor.chip_id=0; IICreadBytes(BMI160_I2C_ADDR,BMI160_CHIP_ID_ADDR, &amp;bmi160sensor.chip_id, 1); printf(&quot;bmi_id=%d\n&quot;,bmi160sensor.chip_id);// bmi160_get_regs2(BMI160_CHIP_ID_ADDR, &amp;bmi160sensor.chip_id, 1, dev); rslt = bmi160_init(&amp;bmi160sensor); /* Select the Output data rate, range of accelerometer bmi160sensor */ bmi160sensor.accel_cfg.odr = BMI160_ACCEL_ODR_800HZ; bmi160sensor.accel_cfg.range = BMI160_ACCEL_RANGE_4G; bmi160sensor.accel_cfg.bw = BMI160_ACCEL_BW_NORMAL_AVG4; /* Select the power mode of accelerometer bmi160sensor */ bmi160sensor.accel_cfg.power = BMI160_ACCEL_NORMAL_MODE; /* Select the Output data rate, range of Gyroscope bmi160sensor */ bmi160sensor.gyro_cfg.odr = BMI160_GYRO_ODR_800HZ; bmi160sensor.gyro_cfg.range = BMI160_GYRO_RANGE_2000_DPS; bmi160sensor.gyro_cfg.bw = BMI160_GYRO_BW_NORMAL_MODE; /* Select the power mode of Gyroscope bmi160sensor */ bmi160sensor.gyro_cfg.power = BMI160_GYRO_NORMAL_MODE; /* Set the bmi160sensor configuration */ rslt = bmi160_set_sens_conf(&amp;bmi160sensor); /* After the above function call, accel and gyro parameters in the device structure are set with default values, found in the datasheet of the bmi160sensor */&#125; 获取陀螺仪和加速度数据 12345678910111213141516171819202122232425262728293031323334353637383940414243//获取数据void get_accel_gyro_data2(void)&#123; uint8_t data_array[15] = &#123;0&#125;; uint8_t lsb; uint8_t msb; int16_t msblsb; int16_t gx,gy,gz,ax,ay,az; IICreadBytes(BMI160_I2C_ADDR,BMI160_GYRO_DATA_ADDR,data_array,15);//获取陀螺仪的数据 lsb = data_array[0]; msb = data_array[1]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); gx = msblsb; /* gyro X axis data */ lsb = data_array[2]; msb = data_array[3]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); gy = msblsb; /* gyro Y axis data */ lsb = data_array[4]; msb = data_array[5]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); gz = msblsb; /* gyro Z axis data */ /* Accel Data */ lsb = data_array[6]; msb = data_array[7]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); ax = (int16_t)msblsb; /* accel X axis data */ lsb = data_array[8]; msb = data_array[9]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); ay = (int16_t)msblsb; /* accel Y axis data */ lsb = data_array[10]; msb = data_array[11]; msblsb = (int16_t)((msb &lt;&lt; 8) | lsb); az = (int16_t)msblsb; /* accel Z axis data */ printf(&quot;gyro-&gt;x=%d,y=%d,z=%d,accel-&gt;x=%d,y=%d,z=%d \n&quot;,gx,gy,gz,ax,ay,az);&#125; 设置为任意方向中断，这样可以通过示波器查看，当摇晃BMI160时，观察中断通道1是否有高电平产生了。 123456789101112131415161718192021222324252627void bmi160_Interrupt(void)//设置任意方向中断&#123; struct bmi160_int_settg int_config; int8_t rslt = BMI160_OK; /* Select the Interrupt channel/pin */ int_config.int_channel = BMI160_INT_CHANNEL_1;// Interrupt channel/pin 1 /* Select the Interrupt type */ int_config.int_type = BMI160_ACC_ANY_MOTION_INT;// Choosing Any motion interrupt /* Select the interrupt channel/pin settings */ int_config.int_pin_settg.output_en = BMI160_ENABLE;// Enabling interrupt pins to act as output pin int_config.int_pin_settg.output_mode = BMI160_DISABLE;// Choosing push-pull mode for interrupt pin int_config.int_pin_settg.output_type = BMI160_ENABLE;// Choosing active low output int_config.int_pin_settg.edge_ctrl = BMI160_ENABLE;// Choosing edge triggered output int_config.int_pin_settg.input_en = BMI160_DISABLE;// Disabling interrupt pin to act as input int_config.int_pin_settg.latch_dur = BMI160_LATCH_DUR_40_MILLI_SEC;// non-latched output /* Select the Any-motion interrupt parameters */ int_config.int_type_cfg.acc_any_motion_int.anymotion_en = BMI160_ENABLE;// 1- Enable the any-motion, 0- disable any-motion int_config.int_type_cfg.acc_any_motion_int.anymotion_x = BMI160_ENABLE;// Enabling x-axis for any motion interrupt int_config.int_type_cfg.acc_any_motion_int.anymotion_y = BMI160_ENABLE;// Enabling y-axis for any motion interrupt int_config.int_type_cfg.acc_any_motion_int.anymotion_z = BMI160_ENABLE;// Enabling z-axis for any motion interrupt int_config.int_type_cfg.acc_any_motion_int.anymotion_dur = 0;// any-motion duration int_config.int_type_cfg.acc_any_motion_int.anymotion_thr = 100; /* Set the Any-motion interrupt */ rslt=bmi160_set_int_config(&amp;int_config, &amp;bmi160sensor); /* bmi160sensor is an instance of the structure bmi160_dev */&#125; 更多其他详细程序请到我的公众号或者github查找。]]></content>
  </entry>
  <entry>
    <title><![CDATA[美信DS28E05单总线EEPROM通信方式详解（以STM32F030为例）]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%BE%8E%E4%BF%A1DS28E05%E5%8D%95%E6%80%BB%E7%BA%BFEEPROM%E4%B8%8ESTM32F030%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述​ DS28E05是一款112字节用户可编程EEPROM芯片，分为7页，每页16字节。存储器页通过保护字节可单独设置为写保护或者EPROM仿真模式。每个器件都带有唯一的64位ROM注册码(ROM ID)，由工厂刻入器件。DS28E05通过Maxim Integrated单触点1-Wire®接口高速通信，在多点1-Wire网络中，ROM ID作为节点地址。 关键特性单触点1-Wire接口 112字节用户EEPROM，具有1K次写循环 用户存储器可编程为写保护以及OTP EPROM仿真模式 唯一、工厂编程的64位ROM ID 与主机通信速率高达76.9kbps (仅高速模式) 工作范围：3.3V ±10%, -40°C至+85°C IO引脚具有±8kV HBM ESD保护(典型值) 3引脚SOT23和6引脚TSOC封装 应用配件/PCB识别 消费品的售后管理 模拟感应器校准 医用传感器校准数据存储 通信方式与程序​ DS28E05是通过单总线协议连接的，根据文档显示，标准的单总线协议是不行的，只能使用快速的单总线协议（Overdrive Speed）才行。 如图为读写周期的时间，最短的读写周期仅有2个微秒，注意读的时候不要超过2个微秒，否则就读不出数据了。 复位时序图 12345678910111213141516171819202122/******************************************1-Wire器件复位, 并检查应答;有应答返回0, 无应答返回1*******************************************/ unsigned char Reset( void )&#123; unsigned char testCount = 50; GPIO_DS28E05_Out_Mode(); DS28E05_Write_1(); DS28E05_Write_0(); delay_us(60); //复位60us低脉冲保持 DS28E05_Write_1(); //释放总线后9us读应答 GPIO_DS28E05_Input_Mode(); while(testCount--) &#123; if( 0 == DS28E05_ReadBit() ) &#123; delay_us(2); return 0; &#125; &#125; return 1;&#125; 写数据时序图 写数据程序1234567891011121314151617181920212223/****************************************** 写数据位1*******************************************/void WriteBit_1( void )&#123; DS28E05_Write_1(); DS28E05_Write_0(); //拉低总线保持1us delay_us(1); DS28E05_Write_1(); //释放总线延时大于12us delay_us(20);//20us&#125;/****************************************** 写数据位0*******************************************/void WriteBit_0( void )&#123; DS28E05_Write_1(); DS28E05_Write_0(); //拉低总线保持8-16us delay_us(12); //9-10us DS28E05_Write_1(); //释放总线延时6us delay_us(9);&#125; 读数据程序 12345678910111213141516/****************************************** 读数据位*******************************************/unsigned char value1;static unsigned char Read_Bit( void )&#123; GPIO_DS28E05_Out_Mode(); DS28E05_Write_1(); DS28E05_Write_0(); //拉低总线保持1us delay_us(1); DS28E05_Write_1(); DS28e05_IO_IN();//最重要的一步，一定要用寄存器操作，否则会错过读取的时间，经检测，整个读取周期为2-3微妙 value1 = DS28E05_ReadBit(); delay_us(2); return value1; &#125; 写一个字节1234567891011121314151617181920/****************************************** 写字节*******************************************/static void Write_Byte( unsigned char value )&#123; unsigned char i; GPIO_DS28E05_Out_Mode(); for( i = 0; i &lt; 8; i++ ) &#123; if( value &amp; 0x01 ) &#123; WriteBit_1(); &#125; else &#123; WriteBit_0(); &#125; value = value &gt;&gt; 1; &#125;&#125; 读一个字节123456789101112131415/****************************************** 读字节*******************************************/static unsigned char Read_Byte( void )&#123; int i, value; value = 0; for( i = 0; i &lt; 8; i++ ) &#123; value &gt;&gt;= 1; if( Read_Bit() ) value |= 0x80; &#125; return value;&#125; 读写ROM和flash123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/******************************************功能：读8位家族码;48位序列号;8位CRC码;读取成功返回0参数：*id--读取的数据存放地址返回：0--操作成功；1--总线不可用;*******************************************/unsigned char DS28E05_ReadRom( unsigned char *id )&#123; unsigned char i,j; while(Reset()); Write_Byte( Rom_Read_Cmd ); //写命令 for( i = 0; i &lt; 8; i++ ) &#123; j= Read_Byte(); *id++ = j; &#125; return ( 0 ); &#125;/******************************************功能： 读EPROM参数： tgaddr--目标地址; len--要读取的字节数; *buffer--存放地址返回：0--操作成功；1--总线不可用;*******************************************/unsigned char DS28E05_ReadMemory( unsigned char tgaddr, unsigned char len, unsigned char * buffer )&#123; unsigned char i; if( Reset() != 0 ) return ( 1 ); Write_Byte( Rom_Skip_Cmd ); //写命令 Write_Byte( Memory_Read_Cmd ); //写命令 Write_Byte( tgaddr ); //写地址低字节 Write_Byte( 0 ); //写地址高字节 for( i = 0; i &lt; len; i++ ) &#123; buffer[ i ] = Read_Byte(); &#125; Reset(); return ( 0 ); &#125;//写eepromint ds28e05WriteMemory(uint8_t address, char *buffer, int length)&#123; uint8_t a,b; uint8_t sf,ef; uint8_t sb[2]=&#123;0&#125;; uint8_t eb[2]=&#123;0&#125;; uint8_t spage, epage, npage, wpage; uint8_t nseg, wseg=0; uint8_t wBytes=0, rBytes=0, wAddr = 0; // Calculate pages spage = ((address &amp; PAGE_MASK) &gt;&gt; 4); epage = (((address + length) &amp; PAGE_MASK) &gt;&gt; 4); if (epage == NUM_PAGES) epage = NUM_PAGES - 1; npage = epage - spage; printf(&quot;spage=%d,epage=%d\n&quot;,spage,epage); printf(&quot;npage=%d,length=%d\n&quot;,npage,length); //This memory must be written respecting 16bits boundaries sf = (address&amp;0x01) != 0; ef = ((address+length)&amp;0x01) != 0; printf(&quot;sf=%d,ef=%d\n&quot;,sf,ef); if (ef) &#123; DS28E05_ReadMemory( address+length,1, &amp;eb[1]); eb[0] = buffer[length-1]; length++; &#125; if (sf) &#123; DS28E05_ReadMemory(address-1,1, &amp;sb[0]); sb[1] = buffer[0]; length++; address--; &#125; // Write pages for (wpage = 0; wpage &lt;= npage; wpage++) &#123; wAddr = address + wBytes; // Calculate segments to write if ((length - wBytes) &gt; (BYTES_PER_PAGE)) // Will we pass a page boudary if (wAddr % (SEG_SIZE * BYTES_PER_SEG) == 0) nseg = SEG_SIZE; else nseg = (BYTES_PER_PAGE - (wAddr % (BYTES_PER_PAGE))) &gt;&gt; 1; else nseg = ((length - wBytes) &amp; SEG_MASK) &gt;&gt; 1; printf(&quot;nseg=%d\n&quot;,nseg); if( Reset() != 0 ) return ( 1 ); Write_Byte( Rom_Skip_Cmd ); Write_Byte(DS28E05_WRITE_MEMORY); Write_Byte(wAddr); Write_Byte(0xff); // Write segments within page for (wseg = 0; wseg &lt; nseg; wseg++) &#123; if (sf) &#123; Write_Byte(sb[0]); Write_Byte(sb[1]); wBytes += 2; rBytes++; sf = 0; &#125; else if (ef &amp;&amp; (length - wBytes) &lt;= 2) &#123; Write_Byte(eb[0]); Write_Byte(eb[1]); wBytes += 2; rBytes++; ef = 0; &#125; else &#123; Write_Byte(buffer[rBytes]); Write_Byte(buffer[rBytes+1]); wBytes += 2; rBytes += 2; &#125; a = Read_Byte(); b = Read_Byte(); printf(&quot;Readback: %02x %02x (%c%c)\n&quot;, a, b, a, b); Write_Byte(0xff); delay_ms(16); a = Read_Byte(); printf(&quot;Verification byte: %02x\n&quot;, a); if(a !=0xAA) goto error; &#125; Reset();; &#125; return 1;error: Reset(); return 0;&#125; 详细的程序，请到我的github仓库查找或者关注我的公众号索取。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深圳的同学注意了，你也可以免费下载知网论文]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%B7%B1%E5%9C%B3%E7%9A%84%E5%90%8C%E5%AD%A6%E6%B3%A8%E6%84%8F%E4%BA%86%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E7%9F%A5%E7%BD%91%E8%AE%BA%E6%96%87%2F</url>
    <content type="text"><![CDATA[​ 受知乎回答启发，深圳的同学也能享受到免费下载知网的文章的便利，条件便是要拥有深圳图书馆的借书证。 以下是操作步骤： ​ 1.先用借书证，登录深圳图书馆[https://www.szlib.org.cn/ ],如图找到数字资源-，然后点击馆外访问， ，然后就可以用知网下载了。 怎么样，是不是很方便呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[这是一个新的博客]]></title>
    <url>%2F2019%2F05%2F12%2F%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是一个博客，如有问题请加QQ咨询916100357.]]></content>
  </entry>
</search>
